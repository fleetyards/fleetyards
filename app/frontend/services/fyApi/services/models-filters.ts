/**
 * Generated by orval v7.7.0 🍺
 * Do not edit manually.
 * FleetYards.net API
 * OpenAPI spec version: v1
 */
import {
  useQuery
} from '@tanstack/vue-query';
import type {
  DataTag,
  QueryFunction,
  QueryKey,
  UseQueryOptions,
  UseQueryReturnType
} from '@tanstack/vue-query';

import {
  unref
} from 'vue';

import {
  faker
} from '@faker-js/faker';

import {
  HttpResponse,
  delay,
  http
} from 'msw';

import type {
  FilterOption
} from '../models';

import { axiosClient } from '../../axiosClient';
import type { ErrorType } from '../../axiosClient';
import { customQueryOptions } from '../../customQueryOptions';





/**
 * @summary Model classifications Filters
 */
export const modelClassificationsFilters = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosClient<FilterOption[]>(
      {url: `/filters/models/classifications`, method: 'GET', signal
    },
      );
    }
  

const getModelClassificationsFiltersQueryKey = () => {
    return ['filters','models','classifications'] as const;
    }

    
export const useModelClassificationsFiltersQueryOptions = <TData = Awaited<ReturnType<typeof modelClassificationsFilters>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelClassificationsFilters>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getModelClassificationsFiltersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelClassificationsFilters>>> = ({ signal }) => modelClassificationsFilters(signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof modelClassificationsFilters>>, TError, TData> 
}

export type ModelClassificationsFiltersQueryResult = NonNullable<Awaited<ReturnType<typeof modelClassificationsFilters>>>
export type ModelClassificationsFiltersQueryError = ErrorType<unknown>


/**
 * @summary Model classifications Filters
 */

export function useModelClassificationsFilters<TData = Awaited<ReturnType<typeof modelClassificationsFilters>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelClassificationsFilters>>, TError, TData>>, }

  ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = useModelClassificationsFiltersQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}



/**
 * @summary Model Dock Sizes Filters
 */
export const modelDockSizesFilters = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosClient<FilterOption[]>(
      {url: `/filters/models/dock-sizes`, method: 'GET', signal
    },
      );
    }
  

const getModelDockSizesFiltersQueryKey = () => {
    return ['filters','models','dock-sizes'] as const;
    }

    
export const useModelDockSizesFiltersQueryOptions = <TData = Awaited<ReturnType<typeof modelDockSizesFilters>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelDockSizesFilters>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getModelDockSizesFiltersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelDockSizesFilters>>> = ({ signal }) => modelDockSizesFilters(signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof modelDockSizesFilters>>, TError, TData> 
}

export type ModelDockSizesFiltersQueryResult = NonNullable<Awaited<ReturnType<typeof modelDockSizesFilters>>>
export type ModelDockSizesFiltersQueryError = ErrorType<unknown>


/**
 * @summary Model Dock Sizes Filters
 */

export function useModelDockSizesFilters<TData = Awaited<ReturnType<typeof modelDockSizesFilters>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelDockSizesFilters>>, TError, TData>>, }

  ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = useModelDockSizesFiltersQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}



/**
 * @summary Model focus Filters
 */
export const modelFocusFilters = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosClient<FilterOption[]>(
      {url: `/filters/models/focus`, method: 'GET', signal
    },
      );
    }
  

const getModelFocusFiltersQueryKey = () => {
    return ['filters','models','focus'] as const;
    }

    
export const useModelFocusFiltersQueryOptions = <TData = Awaited<ReturnType<typeof modelFocusFilters>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelFocusFilters>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getModelFocusFiltersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelFocusFilters>>> = ({ signal }) => modelFocusFilters(signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof modelFocusFilters>>, TError, TData> 
}

export type ModelFocusFiltersQueryResult = NonNullable<Awaited<ReturnType<typeof modelFocusFilters>>>
export type ModelFocusFiltersQueryError = ErrorType<unknown>


/**
 * @summary Model focus Filters
 */

export function useModelFocusFilters<TData = Awaited<ReturnType<typeof modelFocusFilters>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelFocusFilters>>, TError, TData>>, }

  ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = useModelFocusFiltersQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}



/**
 * @summary Models Filters
 */
export const modelFilters = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosClient<FilterOption[]>(
      {url: `/filters/models`, method: 'GET', signal
    },
      );
    }
  

const getModelFiltersQueryKey = () => {
    return ['filters','models'] as const;
    }

    
export const useModelFiltersQueryOptions = <TData = Awaited<ReturnType<typeof modelFilters>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelFilters>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getModelFiltersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelFilters>>> = ({ signal }) => modelFilters(signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof modelFilters>>, TError, TData> 
}

export type ModelFiltersQueryResult = NonNullable<Awaited<ReturnType<typeof modelFilters>>>
export type ModelFiltersQueryError = ErrorType<unknown>


/**
 * @summary Models Filters
 */

export function useModelFilters<TData = Awaited<ReturnType<typeof modelFilters>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelFilters>>, TError, TData>>, }

  ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = useModelFiltersQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}



/**
 * @summary Model Production states Filters
 */
export const modelProductionStatesFilters = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosClient<FilterOption[]>(
      {url: `/filters/models/production-states`, method: 'GET', signal
    },
      );
    }
  

const getModelProductionStatesFiltersQueryKey = () => {
    return ['filters','models','production-states'] as const;
    }

    
export const useModelProductionStatesFiltersQueryOptions = <TData = Awaited<ReturnType<typeof modelProductionStatesFilters>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelProductionStatesFilters>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getModelProductionStatesFiltersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelProductionStatesFilters>>> = ({ signal }) => modelProductionStatesFilters(signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof modelProductionStatesFilters>>, TError, TData> 
}

export type ModelProductionStatesFiltersQueryResult = NonNullable<Awaited<ReturnType<typeof modelProductionStatesFilters>>>
export type ModelProductionStatesFiltersQueryError = ErrorType<unknown>


/**
 * @summary Model Production states Filters
 */

export function useModelProductionStatesFilters<TData = Awaited<ReturnType<typeof modelProductionStatesFilters>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelProductionStatesFilters>>, TError, TData>>, }

  ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = useModelProductionStatesFiltersQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}



/**
 * @summary Model Sizes Filters
 */
export const modelSizesFilters = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosClient<FilterOption[]>(
      {url: `/filters/models/sizes`, method: 'GET', signal
    },
      );
    }
  

const getModelSizesFiltersQueryKey = () => {
    return ['filters','models','sizes'] as const;
    }

    
export const useModelSizesFiltersQueryOptions = <TData = Awaited<ReturnType<typeof modelSizesFilters>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelSizesFilters>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getModelSizesFiltersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelSizesFilters>>> = ({ signal }) => modelSizesFilters(signal);

      

      const customOptions = customQueryOptions({...queryOptions, queryKey, queryFn});

   return  customOptions as UseQueryOptions<Awaited<ReturnType<typeof modelSizesFilters>>, TError, TData> 
}

export type ModelSizesFiltersQueryResult = NonNullable<Awaited<ReturnType<typeof modelSizesFilters>>>
export type ModelSizesFiltersQueryError = ErrorType<unknown>


/**
 * @summary Model Sizes Filters
 */

export function useModelSizesFilters<TData = Awaited<ReturnType<typeof modelSizesFilters>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelSizesFilters>>, TError, TData>>, }

  ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = useModelSizesFiltersQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}





export const getModelClassificationsFiltersResponseMock = (): FilterOption[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({category: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), icon: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), label: faker.string.alpha(20), value: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20), null]),faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]),]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined])})))

export const getModelDockSizesFiltersResponseMock = (): FilterOption[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({category: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), icon: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), label: faker.string.alpha(20), value: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20), null]),faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]),]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined])})))

export const getModelFocusFiltersResponseMock = (): FilterOption[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({category: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), icon: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), label: faker.string.alpha(20), value: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20), null]),faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]),]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined])})))

export const getModelFiltersResponseMock = (): FilterOption[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({category: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), icon: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), label: faker.string.alpha(20), value: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20), null]),faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]),]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined])})))

export const getModelProductionStatesFiltersResponseMock = (): FilterOption[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({category: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), icon: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), label: faker.string.alpha(20), value: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20), null]),faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]),]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined])})))

export const getModelSizesFiltersResponseMock = (): FilterOption[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({category: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), icon: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), label: faker.string.alpha(20), value: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20), null]),faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]),]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined])})))


export const getModelClassificationsFiltersMockHandler = (overrideResponse?: FilterOption[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<FilterOption[]> | FilterOption[])) => {
  return http.get('*/filters/models/classifications', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getModelClassificationsFiltersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getModelDockSizesFiltersMockHandler = (overrideResponse?: FilterOption[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<FilterOption[]> | FilterOption[])) => {
  return http.get('*/filters/models/dock-sizes', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getModelDockSizesFiltersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getModelFocusFiltersMockHandler = (overrideResponse?: FilterOption[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<FilterOption[]> | FilterOption[])) => {
  return http.get('*/filters/models/focus', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getModelFocusFiltersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getModelFiltersMockHandler = (overrideResponse?: FilterOption[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<FilterOption[]> | FilterOption[])) => {
  return http.get('*/filters/models', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getModelFiltersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getModelProductionStatesFiltersMockHandler = (overrideResponse?: FilterOption[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<FilterOption[]> | FilterOption[])) => {
  return http.get('*/filters/models/production-states', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getModelProductionStatesFiltersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getModelSizesFiltersMockHandler = (overrideResponse?: FilterOption[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<FilterOption[]> | FilterOption[])) => {
  return http.get('*/filters/models/sizes', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getModelSizesFiltersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}
export const getModelsFiltersMock = () => [
  getModelClassificationsFiltersMockHandler(),
  getModelDockSizesFiltersMockHandler(),
  getModelFocusFiltersMockHandler(),
  getModelFiltersMockHandler(),
  getModelProductionStatesFiltersMockHandler(),
  getModelSizesFiltersMockHandler()
]
