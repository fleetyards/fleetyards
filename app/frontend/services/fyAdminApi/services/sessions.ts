/**
 * Generated by orval v7.7.0 üç∫
 * Do not edit manually.
 * FleetYards.net Command API
 * OpenAPI spec version: v1
 */
import {
  useMutation
} from '@tanstack/vue-query';
import type {
  MutationFunction,
  UseMutationOptions,
  UseMutationReturnType
} from '@tanstack/vue-query';

import {
  unref
} from 'vue';
import type {
  MaybeRef
} from 'vue';

import type {
  SessionInput,
  StandardError
} from '../models';

import {
  faker
} from '@faker-js/faker';

import {
  HttpResponse,
  delay,
  http
} from 'msw';

import type {
  StandardMessage
} from '../models';

import { axiosClient } from '../../axiosAdminClient';
import type { ErrorType } from '../../axiosAdminClient';





/**
 * @summary create session
 */
export const createSession = (
    sessionInput: MaybeRef<SessionInput>,
 signal?: AbortSignal
) => {
      sessionInput = unref(sessionInput);
      
      return axiosClient<StandardMessage>(
      {url: `/sessions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sessionInput, signal
    },
      );
    }
  


export const getCreateSessionMutationOptions = <TError = ErrorType<StandardError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,{data: SessionInput}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,{data: SessionInput}, TContext> => {
    
const mutationKey = ['createSession'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSession>>, {data: SessionInput}> = (props) => {
          const {data} = props ?? {};

          return  createSession(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSessionMutationResult = NonNullable<Awaited<ReturnType<typeof createSession>>>
    export type CreateSessionMutationBody = SessionInput
    export type CreateSessionMutationError = ErrorType<StandardError>

    /**
 * @summary create session
 */
export const useCreateSession = <TError = ErrorType<StandardError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,{data: SessionInput}, TContext>, }
): UseMutationReturnType<
        Awaited<ReturnType<typeof createSession>>,
        TError,
        {data: SessionInput},
        TContext
      > => {

      const mutationOptions = getCreateSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Destroy Session
 */
export const destroySession = (
    
 ) => {
      
      
      return axiosClient<void>(
      {url: `/sessions`, method: 'DELETE'
    },
      );
    }
  


export const getDestroySessionMutationOptions = <TError = ErrorType<StandardError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof destroySession>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof destroySession>>, TError,void, TContext> => {
    
const mutationKey = ['destroySession'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof destroySession>>, void> = () => {
          

          return  destroySession()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DestroySessionMutationResult = NonNullable<Awaited<ReturnType<typeof destroySession>>>
    
    export type DestroySessionMutationError = ErrorType<StandardError>

    /**
 * @summary Destroy Session
 */
export const useDestroySession = <TError = ErrorType<StandardError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof destroySession>>, TError,void, TContext>, }
): UseMutationReturnType<
        Awaited<ReturnType<typeof destroySession>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getDestroySessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    

export const getCreateSessionResponseMock = (overrideResponse: Partial< StandardMessage > = {}): StandardMessage => ({code: faker.string.alpha(20), message: faker.string.alpha(20), ...overrideResponse})


export const getCreateSessionMockHandler = (overrideResponse?: StandardMessage | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<StandardMessage> | StandardMessage)) => {
  return http.post('*/sessions', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getCreateSessionResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDestroySessionMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void)) => {
  return http.delete('*/sessions', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  })
}
export const getSessionsMock = () => [
  getCreateSessionMockHandler(),
  getDestroySessionMockHandler()
]
