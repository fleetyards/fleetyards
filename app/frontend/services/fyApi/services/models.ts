/**
 * Generated by orval v7.5.0 üç∫
 * Do not edit manually.
 * FleetYards.net API
 * OpenAPI spec version: v1
 */
import { useQuery } from "@tanstack/vue-query";
import type {
  DataTag,
  QueryFunction,
  QueryKey,
  UseQueryOptions,
  UseQueryReturnType,
} from "@tanstack/vue-query";
import { computed, unref } from "vue";
import type { MaybeRef } from "vue";
import type {
  Images,
  Model,
  ModelExtended,
  ModelHardpoints200Item,
  ModelHardpointsParams,
  ModelImagesParams,
  ModelLoanersParams,
  ModelModulePackages,
  ModelModulePackagesParams,
  ModelModules,
  ModelModulesParams,
  ModelPaint,
  ModelUpgrade,
  ModelVariantsParams,
  ModelVideosParams,
  Models,
  ModelsEmbedParams,
  ModelsParams,
  ModelsUpdatedParams,
  ModelsWithDocksParams,
  StandardError,
  Videos,
} from "../models";
import { axiosClient } from "../axiosClient";
import type { ErrorType } from "../axiosClient";

/**
 * @summary Embed Models
 */
export const modelsEmbed = (
  params: MaybeRef<ModelsEmbedParams>,
  signal?: AbortSignal,
) => {
  params = unref(params);

  return axiosClient<Model[]>({
    url: `/models/embed`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

export const getModelsEmbedQueryKey = (params: MaybeRef<ModelsEmbedParams>) => {
  return ["models", "embed", ...(params ? [params] : [])] as const;
};

export const getModelsEmbedQueryOptions = <
  TData = Awaited<ReturnType<typeof modelsEmbed>>,
  TError = ErrorType<unknown>,
>(
  params: MaybeRef<ModelsEmbedParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelsEmbed>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelsEmbedQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsEmbed>>> = ({
    signal,
  }) => modelsEmbed(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof modelsEmbed>>,
    TError,
    TData
  >;
};

export type ModelsEmbedQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelsEmbed>>
>;
export type ModelsEmbedQueryError = ErrorType<unknown>;

/**
 * @summary Embed Models
 */

export function useModelsEmbed<
  TData = Awaited<ReturnType<typeof modelsEmbed>>,
  TError = ErrorType<unknown>,
>(
  params: MaybeRef<ModelsEmbedParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelsEmbed>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getModelsEmbedQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Models List
 */
export const models = (
  params?: MaybeRef<ModelsParams>,
  signal?: AbortSignal,
) => {
  params = unref(params);

  return axiosClient<Models>({
    url: `/models`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

export const getModelsQueryKey = (params?: MaybeRef<ModelsParams>) => {
  return ["models", ...(params ? [params] : [])] as const;
};

export const getModelsQueryOptions = <
  TData = Awaited<ReturnType<typeof models>>,
  TError = ErrorType<unknown>,
>(
  params?: MaybeRef<ModelsParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof models>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof models>>> = ({
    signal,
  }) => models(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof models>>,
    TError,
    TData
  >;
};

export type ModelsQueryResult = NonNullable<Awaited<ReturnType<typeof models>>>;
export type ModelsQueryError = ErrorType<unknown>;

/**
 * @summary Models List
 */

export function useModels<
  TData = Awaited<ReturnType<typeof models>>,
  TError = ErrorType<unknown>,
>(
  params?: MaybeRef<ModelsParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof models>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getModelsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Latest Models
 */
export const modelsLatest = (signal?: AbortSignal) => {
  return axiosClient<Model[]>({ url: `/models/latest`, method: "GET", signal });
};

export const getModelsLatestQueryKey = () => {
  return ["models", "latest"] as const;
};

export const getModelsLatestQueryOptions = <
  TData = Awaited<ReturnType<typeof modelsLatest>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof modelsLatest>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelsLatestQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsLatest>>> = ({
    signal,
  }) => modelsLatest(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof modelsLatest>>,
    TError,
    TData
  >;
};

export type ModelsLatestQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelsLatest>>
>;
export type ModelsLatestQueryError = ErrorType<unknown>;

/**
 * @summary Latest Models
 */

export function useModelsLatest<
  TData = Awaited<ReturnType<typeof modelsLatest>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof modelsLatest>>, TError, TData>
  >;
}): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getModelsLatestQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Detail
 */
export const model = (slug: MaybeRef<string>, signal?: AbortSignal) => {
  slug = unref(slug);

  return axiosClient<ModelExtended>({
    url: `/models/${slug}`,
    method: "GET",
    signal,
  });
};

export const getModelQueryKey = (slug: MaybeRef<string>) => {
  return ["models", slug] as const;
};

export const getModelQueryOptions = <
  TData = Awaited<ReturnType<typeof model>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof model>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelQueryKey(slug);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof model>>> = ({
    signal,
  }) => model(slug, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(slug)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof model>>, TError, TData>;
};

export type ModelQueryResult = NonNullable<Awaited<ReturnType<typeof model>>>;
export type ModelQueryError = ErrorType<StandardError>;

/**
 * @summary Model Detail
 */

export function useModel<
  TData = Awaited<ReturnType<typeof model>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof model>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getModelQueryOptions(slug, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Hardpoints
 */
export const modelHardpoints = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelHardpointsParams>,
  signal?: AbortSignal,
) => {
  slug = unref(slug);
  params = unref(params);

  return axiosClient<ModelHardpoints200Item[]>({
    url: `/models/${slug}/hardpoints`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

export const getModelHardpointsQueryKey = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelHardpointsParams>,
) => {
  return ["models", slug, "hardpoints", ...(params ? [params] : [])] as const;
};

export const getModelHardpointsQueryOptions = <
  TData = Awaited<ReturnType<typeof modelHardpoints>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelHardpointsParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelHardpoints>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelHardpointsQueryKey(slug, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelHardpoints>>> = ({
    signal,
  }) => modelHardpoints(slug, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(slug)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof modelHardpoints>>,
    TError,
    TData
  >;
};

export type ModelHardpointsQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelHardpoints>>
>;
export type ModelHardpointsQueryError = ErrorType<StandardError>;

/**
 * @summary Model Hardpoints
 */

export function useModelHardpoints<
  TData = Awaited<ReturnType<typeof modelHardpoints>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelHardpointsParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelHardpoints>>,
        TError,
        TData
      >
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getModelHardpointsQueryOptions(slug, params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Images
 */
export const modelImages = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelImagesParams>,
  signal?: AbortSignal,
) => {
  slug = unref(slug);
  params = unref(params);

  return axiosClient<Images>({
    url: `/models/${slug}/images`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

export const getModelImagesQueryKey = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelImagesParams>,
) => {
  return ["models", slug, "images", ...(params ? [params] : [])] as const;
};

export const getModelImagesQueryOptions = <
  TData = Awaited<ReturnType<typeof modelImages>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelImagesParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelImages>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelImagesQueryKey(slug, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelImages>>> = ({
    signal,
  }) => modelImages(slug, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(slug)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof modelImages>>, TError, TData>;
};

export type ModelImagesQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelImages>>
>;
export type ModelImagesQueryError = ErrorType<StandardError>;

/**
 * @summary Model Images
 */

export function useModelImages<
  TData = Awaited<ReturnType<typeof modelImages>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelImagesParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelImages>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getModelImagesQueryOptions(slug, params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Videos
 */
export const modelVideos = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelVideosParams>,
  signal?: AbortSignal,
) => {
  slug = unref(slug);
  params = unref(params);

  return axiosClient<Videos>({
    url: `/models/${slug}/videos`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

export const getModelVideosQueryKey = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelVideosParams>,
) => {
  return ["models", slug, "videos", ...(params ? [params] : [])] as const;
};

export const getModelVideosQueryOptions = <
  TData = Awaited<ReturnType<typeof modelVideos>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelVideosParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelVideos>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelVideosQueryKey(slug, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelVideos>>> = ({
    signal,
  }) => modelVideos(slug, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(slug)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof modelVideos>>, TError, TData>;
};

export type ModelVideosQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelVideos>>
>;
export type ModelVideosQueryError = ErrorType<StandardError>;

/**
 * @summary Model Videos
 */

export function useModelVideos<
  TData = Awaited<ReturnType<typeof modelVideos>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelVideosParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelVideos>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getModelVideosQueryOptions(slug, params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Variants
 */
export const modelVariants = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelVariantsParams>,
  signal?: AbortSignal,
) => {
  slug = unref(slug);
  params = unref(params);

  return axiosClient<Models>({
    url: `/models/${slug}/variants`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

export const getModelVariantsQueryKey = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelVariantsParams>,
) => {
  return ["models", slug, "variants", ...(params ? [params] : [])] as const;
};

export const getModelVariantsQueryOptions = <
  TData = Awaited<ReturnType<typeof modelVariants>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelVariantsParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelVariants>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelVariantsQueryKey(slug, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelVariants>>> = ({
    signal,
  }) => modelVariants(slug, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(slug)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof modelVariants>>,
    TError,
    TData
  >;
};

export type ModelVariantsQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelVariants>>
>;
export type ModelVariantsQueryError = ErrorType<StandardError>;

/**
 * @summary Model Variants
 */

export function useModelVariants<
  TData = Awaited<ReturnType<typeof modelVariants>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelVariantsParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelVariants>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getModelVariantsQueryOptions(slug, params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Loaners
 */
export const modelLoaners = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelLoanersParams>,
  signal?: AbortSignal,
) => {
  slug = unref(slug);
  params = unref(params);

  return axiosClient<Models>({
    url: `/models/${slug}/loaners`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

export const getModelLoanersQueryKey = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelLoanersParams>,
) => {
  return ["models", slug, "loaners", ...(params ? [params] : [])] as const;
};

export const getModelLoanersQueryOptions = <
  TData = Awaited<ReturnType<typeof modelLoaners>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelLoanersParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelLoaners>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelLoanersQueryKey(slug, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelLoaners>>> = ({
    signal,
  }) => modelLoaners(slug, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(slug)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof modelLoaners>>, TError, TData>;
};

export type ModelLoanersQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelLoaners>>
>;
export type ModelLoanersQueryError = ErrorType<StandardError>;

/**
 * @summary Model Loaners
 */

export function useModelLoaners<
  TData = Awaited<ReturnType<typeof modelLoaners>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelLoanersParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelLoaners>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getModelLoanersQueryOptions(slug, params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Snubcrafts
 */
export const modelSnubCrafts = (
  slug: MaybeRef<string>,
  signal?: AbortSignal,
) => {
  slug = unref(slug);

  return axiosClient<Model[]>({
    url: `/models/${slug}/snub-crafts`,
    method: "GET",
    signal,
  });
};

export const getModelSnubCraftsQueryKey = (slug: MaybeRef<string>) => {
  return ["models", slug, "snub-crafts"] as const;
};

export const getModelSnubCraftsQueryOptions = <
  TData = Awaited<ReturnType<typeof modelSnubCrafts>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelSnubCrafts>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelSnubCraftsQueryKey(slug);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelSnubCrafts>>> = ({
    signal,
  }) => modelSnubCrafts(slug, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(slug)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof modelSnubCrafts>>,
    TError,
    TData
  >;
};

export type ModelSnubCraftsQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelSnubCrafts>>
>;
export type ModelSnubCraftsQueryError = ErrorType<StandardError>;

/**
 * @summary Model Snubcrafts
 */

export function useModelSnubCrafts<
  TData = Awaited<ReturnType<typeof modelSnubCrafts>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelSnubCrafts>>,
        TError,
        TData
      >
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getModelSnubCraftsQueryOptions(slug, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Modules
 */
export const modelModules = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelModulesParams>,
  signal?: AbortSignal,
) => {
  slug = unref(slug);
  params = unref(params);

  return axiosClient<ModelModules>({
    url: `/models/${slug}/modules`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

export const getModelModulesQueryKey = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelModulesParams>,
) => {
  return ["models", slug, "modules", ...(params ? [params] : [])] as const;
};

export const getModelModulesQueryOptions = <
  TData = Awaited<ReturnType<typeof modelModules>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelModulesParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelModules>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelModulesQueryKey(slug, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelModules>>> = ({
    signal,
  }) => modelModules(slug, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(slug)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof modelModules>>, TError, TData>;
};

export type ModelModulesQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelModules>>
>;
export type ModelModulesQueryError = ErrorType<StandardError>;

/**
 * @summary Model Modules
 */

export function useModelModules<
  TData = Awaited<ReturnType<typeof modelModules>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelModulesParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelModules>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getModelModulesQueryOptions(slug, params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Module Packages
 */
export const modelModulePackages = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelModulePackagesParams>,
  signal?: AbortSignal,
) => {
  slug = unref(slug);
  params = unref(params);

  return axiosClient<ModelModulePackages>({
    url: `/models/${slug}/module-packages`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

export const getModelModulePackagesQueryKey = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelModulePackagesParams>,
) => {
  return [
    "models",
    slug,
    "module-packages",
    ...(params ? [params] : []),
  ] as const;
};

export const getModelModulePackagesQueryOptions = <
  TData = Awaited<ReturnType<typeof modelModulePackages>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelModulePackagesParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelModulePackages>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelModulePackagesQueryKey(slug, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof modelModulePackages>>
  > = ({ signal }) => modelModulePackages(slug, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(slug)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof modelModulePackages>>,
    TError,
    TData
  >;
};

export type ModelModulePackagesQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelModulePackages>>
>;
export type ModelModulePackagesQueryError = ErrorType<StandardError>;

/**
 * @summary Model Module Packages
 */

export function useModelModulePackages<
  TData = Awaited<ReturnType<typeof modelModulePackages>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelModulePackagesParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelModulePackages>>,
        TError,
        TData
      >
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getModelModulePackagesQueryOptions(
    slug,
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Upgrades
 */
export const modelUpgrades = (slug: MaybeRef<string>, signal?: AbortSignal) => {
  slug = unref(slug);

  return axiosClient<ModelUpgrade[]>({
    url: `/models/${slug}/upgrades`,
    method: "GET",
    signal,
  });
};

export const getModelUpgradesQueryKey = (slug: MaybeRef<string>) => {
  return ["models", slug, "upgrades"] as const;
};

export const getModelUpgradesQueryOptions = <
  TData = Awaited<ReturnType<typeof modelUpgrades>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelUpgrades>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelUpgradesQueryKey(slug);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelUpgrades>>> = ({
    signal,
  }) => modelUpgrades(slug, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(slug)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof modelUpgrades>>,
    TError,
    TData
  >;
};

export type ModelUpgradesQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelUpgrades>>
>;
export type ModelUpgradesQueryError = ErrorType<StandardError>;

/**
 * @summary Model Upgrades
 */

export function useModelUpgrades<
  TData = Awaited<ReturnType<typeof modelUpgrades>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelUpgrades>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getModelUpgradesQueryOptions(slug, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Paints
 */
export const modelPaints = (slug: MaybeRef<string>, signal?: AbortSignal) => {
  slug = unref(slug);

  return axiosClient<ModelPaint[]>({
    url: `/models/${slug}/paints`,
    method: "GET",
    signal,
  });
};

export const getModelPaintsQueryKey = (slug: MaybeRef<string>) => {
  return ["models", slug, "paints"] as const;
};

export const getModelPaintsQueryOptions = <
  TData = Awaited<ReturnType<typeof modelPaints>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelPaints>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelPaintsQueryKey(slug);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelPaints>>> = ({
    signal,
  }) => modelPaints(slug, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(slug)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof modelPaints>>, TError, TData>;
};

export type ModelPaintsQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelPaints>>
>;
export type ModelPaintsQueryError = ErrorType<StandardError>;

/**
 * @summary Model Paints
 */

export function useModelPaints<
  TData = Awaited<ReturnType<typeof modelPaints>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelPaints>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getModelPaintsQueryOptions(slug, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @deprecated
 * @summary Model Storeimage
 */
export const modelStoreImage = (
  slug: MaybeRef<string>,
  signal?: AbortSignal,
) => {
  slug = unref(slug);

  return axiosClient<unknown>({
    url: `/models/${slug}/store-image`,
    method: "GET",
    signal,
  });
};

export const getModelStoreImageQueryKey = (slug: MaybeRef<string>) => {
  return ["models", slug, "store-image"] as const;
};

export const getModelStoreImageQueryOptions = <
  TData = Awaited<ReturnType<typeof modelStoreImage>>,
  TError = ErrorType<void>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelStoreImage>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelStoreImageQueryKey(slug);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelStoreImage>>> = ({
    signal,
  }) => modelStoreImage(slug, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(slug)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof modelStoreImage>>,
    TError,
    TData
  >;
};

export type ModelStoreImageQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelStoreImage>>
>;
export type ModelStoreImageQueryError = ErrorType<void>;

/**
 * @deprecated
 * @summary Model Storeimage
 */

export function useModelStoreImage<
  TData = Awaited<ReturnType<typeof modelStoreImage>>,
  TError = ErrorType<void>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelStoreImage>>,
        TError,
        TData
      >
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getModelStoreImageQueryOptions(slug, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @deprecated
 * @summary Model Fleetchart Image
 */
export const modelFleetchartImage = (
  slug: MaybeRef<string>,
  signal?: AbortSignal,
) => {
  slug = unref(slug);

  return axiosClient<unknown>({
    url: `/models/${slug}/fleetchart-image`,
    method: "GET",
    signal,
  });
};

export const getModelFleetchartImageQueryKey = (slug: MaybeRef<string>) => {
  return ["models", slug, "fleetchart-image"] as const;
};

export const getModelFleetchartImageQueryOptions = <
  TData = Awaited<ReturnType<typeof modelFleetchartImage>>,
  TError = ErrorType<void | StandardError>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelFleetchartImage>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelFleetchartImageQueryKey(slug);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof modelFleetchartImage>>
  > = ({ signal }) => modelFleetchartImage(slug, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(slug)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof modelFleetchartImage>>,
    TError,
    TData
  >;
};

export type ModelFleetchartImageQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelFleetchartImage>>
>;
export type ModelFleetchartImageQueryError = ErrorType<void | StandardError>;

/**
 * @deprecated
 * @summary Model Fleetchart Image
 */

export function useModelFleetchartImage<
  TData = Awaited<ReturnType<typeof modelFleetchartImage>>,
  TError = ErrorType<void | StandardError>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelFleetchartImage>>,
        TError,
        TData
      >
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getModelFleetchartImageQueryOptions(slug, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Available Model-Slugs
 */
export const modelsSlugs = (signal?: AbortSignal) => {
  return axiosClient<void>({ url: `/models/slugs`, method: "GET", signal });
};

export const getModelsSlugsQueryKey = () => {
  return ["models", "slugs"] as const;
};

export const getModelsSlugsQueryOptions = <
  TData = Awaited<ReturnType<typeof modelsSlugs>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof modelsSlugs>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelsSlugsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsSlugs>>> = ({
    signal,
  }) => modelsSlugs(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof modelsSlugs>>,
    TError,
    TData
  >;
};

export type ModelsSlugsQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelsSlugs>>
>;
export type ModelsSlugsQueryError = ErrorType<unknown>;

/**
 * @summary Available Model-Slugs
 */

export function useModelsSlugs<
  TData = Awaited<ReturnType<typeof modelsSlugs>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof modelsSlugs>>, TError, TData>
  >;
}): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getModelsSlugsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Unscheduled Models
 */
export const modelsUnschduled = (signal?: AbortSignal) => {
  return axiosClient<void>({
    url: `/models/unscheduled`,
    method: "GET",
    signal,
  });
};

export const getModelsUnschduledQueryKey = () => {
  return ["models", "unscheduled"] as const;
};

export const getModelsUnschduledQueryOptions = <
  TData = Awaited<ReturnType<typeof modelsUnschduled>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof modelsUnschduled>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelsUnschduledQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof modelsUnschduled>>
  > = ({ signal }) => modelsUnschduled(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof modelsUnschduled>>,
    TError,
    TData
  >;
};

export type ModelsUnschduledQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelsUnschduled>>
>;
export type ModelsUnschduledQueryError = ErrorType<unknown>;

/**
 * @summary Unscheduled Models
 */

export function useModelsUnschduled<
  TData = Awaited<ReturnType<typeof modelsUnschduled>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof modelsUnschduled>>, TError, TData>
  >;
}): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getModelsUnschduledQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Updated Models
 */
export const modelsUpdated = (
  params?: MaybeRef<ModelsUpdatedParams>,
  signal?: AbortSignal,
) => {
  params = unref(params);

  return axiosClient<void>({
    url: `/models/updated`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

export const getModelsUpdatedQueryKey = (
  params?: MaybeRef<ModelsUpdatedParams>,
) => {
  return ["models", "updated", ...(params ? [params] : [])] as const;
};

export const getModelsUpdatedQueryOptions = <
  TData = Awaited<ReturnType<typeof modelsUpdated>>,
  TError = ErrorType<void>,
>(
  params?: MaybeRef<ModelsUpdatedParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelsUpdated>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelsUpdatedQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsUpdated>>> = ({
    signal,
  }) => modelsUpdated(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof modelsUpdated>>,
    TError,
    TData
  >;
};

export type ModelsUpdatedQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelsUpdated>>
>;
export type ModelsUpdatedQueryError = ErrorType<void>;

/**
 * @summary Updated Models
 */

export function useModelsUpdated<
  TData = Awaited<ReturnType<typeof modelsUpdated>>,
  TError = ErrorType<void>,
>(
  params?: MaybeRef<ModelsUpdatedParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelsUpdated>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getModelsUpdatedQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Models with Docks
 */
export const modelsWithDocks = (
  params?: MaybeRef<ModelsWithDocksParams>,
  signal?: AbortSignal,
) => {
  params = unref(params);

  return axiosClient<Models>({
    url: `/models/with-docks`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

export const getModelsWithDocksQueryKey = (
  params?: MaybeRef<ModelsWithDocksParams>,
) => {
  return ["models", "with-docks", ...(params ? [params] : [])] as const;
};

export const getModelsWithDocksQueryOptions = <
  TData = Awaited<ReturnType<typeof modelsWithDocks>>,
  TError = ErrorType<unknown>,
>(
  params?: MaybeRef<ModelsWithDocksParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelsWithDocks>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelsWithDocksQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsWithDocks>>> = ({
    signal,
  }) => modelsWithDocks(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof modelsWithDocks>>,
    TError,
    TData
  >;
};

export type ModelsWithDocksQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelsWithDocks>>
>;
export type ModelsWithDocksQueryError = ErrorType<unknown>;

/**
 * @summary Models with Docks
 */

export function useModelsWithDocks<
  TData = Awaited<ReturnType<typeof modelsWithDocks>>,
  TError = ErrorType<unknown>,
>(
  params?: MaybeRef<ModelsWithDocksParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelsWithDocks>>,
        TError,
        TData
      >
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getModelsWithDocksQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}
