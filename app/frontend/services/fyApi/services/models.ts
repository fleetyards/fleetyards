/**
 * Generated by orval v7.7.0 üç∫
 * Do not edit manually.
 * FleetYards.net API
 * OpenAPI spec version: v1
 */
import { useQuery } from "@tanstack/vue-query";
import type {
  DataTag,
  QueryFunction,
  QueryKey,
  UseQueryOptions,
  UseQueryReturnType,
} from "@tanstack/vue-query";

import { unref } from "vue";
import type { MaybeRef } from "vue";

import type {
  Images,
  Model,
  ModelExtended,
  ModelHardpoints200Item,
  ModelHardpointsParams,
  ModelImagesParams,
  ModelLoanersParams,
  ModelModulePackages,
  ModelModulePackagesParams,
  ModelModules,
  ModelModulesParams,
  ModelPaint,
  ModelUpgrade,
  ModelVariantsParams,
  ModelVideosParams,
  Models,
  ModelsEmbedParams,
  ModelsParams,
  ModelsUpdatedParams,
  ModelsWithDocksParams,
  StandardError,
  Videos,
} from "../models";

import { axiosClient } from "../axiosClient";
import type { ErrorType } from "../axiosClient";
import { customQueryOptions } from "../../customQueryOptions";

/**
 * @summary Embed Models
 */
export const modelsEmbed = (
  params: MaybeRef<ModelsEmbedParams>,
  signal?: AbortSignal,
) => {
  params = unref(params);

  return axiosClient<Model[]>({
    url: `/models/embed`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

const getModelsEmbedQueryKey = (params: MaybeRef<ModelsEmbedParams>) => {
  return ["models", "embed", ...(params ? [params] : [])] as const;
};

export const useModelsEmbedQueryOptions = <
  TData = Awaited<ReturnType<typeof modelsEmbed>>,
  TError = ErrorType<unknown>,
>(
  params: MaybeRef<ModelsEmbedParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelsEmbed>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelsEmbedQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsEmbed>>> = ({
    signal,
  }) => modelsEmbed(params, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof modelsEmbed>>,
    TError,
    TData
  >;
};

export type ModelsEmbedQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelsEmbed>>
>;
export type ModelsEmbedQueryError = ErrorType<unknown>;

/**
 * @summary Embed Models
 */

export function useModelsEmbed<
  TData = Awaited<ReturnType<typeof modelsEmbed>>,
  TError = ErrorType<unknown>,
>(
  params: MaybeRef<ModelsEmbedParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelsEmbed>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = useModelsEmbedQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Models List
 */
export const models = (
  params?: MaybeRef<ModelsParams>,
  signal?: AbortSignal,
) => {
  params = unref(params);

  return axiosClient<Models>({
    url: `/models`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

const getModelsQueryKey = (params?: MaybeRef<ModelsParams>) => {
  return ["models", ...(params ? [params] : [])] as const;
};

export const useModelsQueryOptions = <
  TData = Awaited<ReturnType<typeof models>>,
  TError = ErrorType<unknown>,
>(
  params?: MaybeRef<ModelsParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof models>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof models>>> = ({
    signal,
  }) => models(params, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof models>>,
    TError,
    TData
  >;
};

export type ModelsQueryResult = NonNullable<Awaited<ReturnType<typeof models>>>;
export type ModelsQueryError = ErrorType<unknown>;

/**
 * @summary Models List
 */

export function useModels<
  TData = Awaited<ReturnType<typeof models>>,
  TError = ErrorType<unknown>,
>(
  params?: MaybeRef<ModelsParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof models>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = useModelsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Latest Models
 */
export const modelsLatest = (signal?: AbortSignal) => {
  return axiosClient<Model[]>({ url: `/models/latest`, method: "GET", signal });
};

const getModelsLatestQueryKey = () => {
  return ["models", "latest"] as const;
};

export const useModelsLatestQueryOptions = <
  TData = Awaited<ReturnType<typeof modelsLatest>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof modelsLatest>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelsLatestQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsLatest>>> = ({
    signal,
  }) => modelsLatest(signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof modelsLatest>>,
    TError,
    TData
  >;
};

export type ModelsLatestQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelsLatest>>
>;
export type ModelsLatestQueryError = ErrorType<unknown>;

/**
 * @summary Latest Models
 */

export function useModelsLatest<
  TData = Awaited<ReturnType<typeof modelsLatest>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof modelsLatest>>, TError, TData>
  >;
}): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = useModelsLatestQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Detail
 */
export const model = (slug: MaybeRef<string>, signal?: AbortSignal) => {
  slug = unref(slug);

  return axiosClient<ModelExtended>({
    url: `/models/${slug}`,
    method: "GET",
    signal,
  });
};

const getModelQueryKey = (slug: MaybeRef<string>) => {
  return ["models", slug] as const;
};

export const useModelQueryOptions = <
  TData = Awaited<ReturnType<typeof model>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof model>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelQueryKey(slug);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof model>>> = ({
    signal,
  }) => model(slug, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof model>>,
    TError,
    TData
  >;
};

export type ModelQueryResult = NonNullable<Awaited<ReturnType<typeof model>>>;
export type ModelQueryError = ErrorType<StandardError>;

/**
 * @summary Model Detail
 */

export function useModel<
  TData = Awaited<ReturnType<typeof model>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof model>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = useModelQueryOptions(slug, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Hardpoints
 */
export const modelHardpoints = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelHardpointsParams>,
  signal?: AbortSignal,
) => {
  slug = unref(slug);
  params = unref(params);

  return axiosClient<ModelHardpoints200Item[]>({
    url: `/models/${slug}/hardpoints`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

const getModelHardpointsQueryKey = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelHardpointsParams>,
) => {
  return ["models", slug, "hardpoints", ...(params ? [params] : [])] as const;
};

export const useModelHardpointsQueryOptions = <
  TData = Awaited<ReturnType<typeof modelHardpoints>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelHardpointsParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelHardpoints>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelHardpointsQueryKey(slug, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelHardpoints>>> = ({
    signal,
  }) => modelHardpoints(slug, params, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof modelHardpoints>>,
    TError,
    TData
  >;
};

export type ModelHardpointsQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelHardpoints>>
>;
export type ModelHardpointsQueryError = ErrorType<StandardError>;

/**
 * @summary Model Hardpoints
 */

export function useModelHardpoints<
  TData = Awaited<ReturnType<typeof modelHardpoints>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelHardpointsParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelHardpoints>>,
        TError,
        TData
      >
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = useModelHardpointsQueryOptions(slug, params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Images
 */
export const modelImages = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelImagesParams>,
  signal?: AbortSignal,
) => {
  slug = unref(slug);
  params = unref(params);

  return axiosClient<Images>({
    url: `/models/${slug}/images`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

const getModelImagesQueryKey = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelImagesParams>,
) => {
  return ["models", slug, "images", ...(params ? [params] : [])] as const;
};

export const useModelImagesQueryOptions = <
  TData = Awaited<ReturnType<typeof modelImages>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelImagesParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelImages>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelImagesQueryKey(slug, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelImages>>> = ({
    signal,
  }) => modelImages(slug, params, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof modelImages>>,
    TError,
    TData
  >;
};

export type ModelImagesQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelImages>>
>;
export type ModelImagesQueryError = ErrorType<StandardError>;

/**
 * @summary Model Images
 */

export function useModelImages<
  TData = Awaited<ReturnType<typeof modelImages>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelImagesParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelImages>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = useModelImagesQueryOptions(slug, params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Videos
 */
export const modelVideos = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelVideosParams>,
  signal?: AbortSignal,
) => {
  slug = unref(slug);
  params = unref(params);

  return axiosClient<Videos>({
    url: `/models/${slug}/videos`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

const getModelVideosQueryKey = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelVideosParams>,
) => {
  return ["models", slug, "videos", ...(params ? [params] : [])] as const;
};

export const useModelVideosQueryOptions = <
  TData = Awaited<ReturnType<typeof modelVideos>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelVideosParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelVideos>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelVideosQueryKey(slug, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelVideos>>> = ({
    signal,
  }) => modelVideos(slug, params, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof modelVideos>>,
    TError,
    TData
  >;
};

export type ModelVideosQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelVideos>>
>;
export type ModelVideosQueryError = ErrorType<StandardError>;

/**
 * @summary Model Videos
 */

export function useModelVideos<
  TData = Awaited<ReturnType<typeof modelVideos>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelVideosParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelVideos>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = useModelVideosQueryOptions(slug, params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Variants
 */
export const modelVariants = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelVariantsParams>,
  signal?: AbortSignal,
) => {
  slug = unref(slug);
  params = unref(params);

  return axiosClient<Models>({
    url: `/models/${slug}/variants`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

const getModelVariantsQueryKey = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelVariantsParams>,
) => {
  return ["models", slug, "variants", ...(params ? [params] : [])] as const;
};

export const useModelVariantsQueryOptions = <
  TData = Awaited<ReturnType<typeof modelVariants>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelVariantsParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelVariants>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelVariantsQueryKey(slug, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelVariants>>> = ({
    signal,
  }) => modelVariants(slug, params, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof modelVariants>>,
    TError,
    TData
  >;
};

export type ModelVariantsQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelVariants>>
>;
export type ModelVariantsQueryError = ErrorType<StandardError>;

/**
 * @summary Model Variants
 */

export function useModelVariants<
  TData = Awaited<ReturnType<typeof modelVariants>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelVariantsParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelVariants>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = useModelVariantsQueryOptions(slug, params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Loaners
 */
export const modelLoaners = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelLoanersParams>,
  signal?: AbortSignal,
) => {
  slug = unref(slug);
  params = unref(params);

  return axiosClient<Models>({
    url: `/models/${slug}/loaners`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

const getModelLoanersQueryKey = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelLoanersParams>,
) => {
  return ["models", slug, "loaners", ...(params ? [params] : [])] as const;
};

export const useModelLoanersQueryOptions = <
  TData = Awaited<ReturnType<typeof modelLoaners>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelLoanersParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelLoaners>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelLoanersQueryKey(slug, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelLoaners>>> = ({
    signal,
  }) => modelLoaners(slug, params, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof modelLoaners>>,
    TError,
    TData
  >;
};

export type ModelLoanersQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelLoaners>>
>;
export type ModelLoanersQueryError = ErrorType<StandardError>;

/**
 * @summary Model Loaners
 */

export function useModelLoaners<
  TData = Awaited<ReturnType<typeof modelLoaners>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelLoanersParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelLoaners>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = useModelLoanersQueryOptions(slug, params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Snubcrafts
 */
export const modelSnubCrafts = (
  slug: MaybeRef<string>,
  signal?: AbortSignal,
) => {
  slug = unref(slug);

  return axiosClient<Model[]>({
    url: `/models/${slug}/snub-crafts`,
    method: "GET",
    signal,
  });
};

const getModelSnubCraftsQueryKey = (slug: MaybeRef<string>) => {
  return ["models", slug, "snub-crafts"] as const;
};

export const useModelSnubCraftsQueryOptions = <
  TData = Awaited<ReturnType<typeof modelSnubCrafts>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelSnubCrafts>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelSnubCraftsQueryKey(slug);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelSnubCrafts>>> = ({
    signal,
  }) => modelSnubCrafts(slug, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof modelSnubCrafts>>,
    TError,
    TData
  >;
};

export type ModelSnubCraftsQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelSnubCrafts>>
>;
export type ModelSnubCraftsQueryError = ErrorType<StandardError>;

/**
 * @summary Model Snubcrafts
 */

export function useModelSnubCrafts<
  TData = Awaited<ReturnType<typeof modelSnubCrafts>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelSnubCrafts>>,
        TError,
        TData
      >
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = useModelSnubCraftsQueryOptions(slug, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Modules
 */
export const modelModules = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelModulesParams>,
  signal?: AbortSignal,
) => {
  slug = unref(slug);
  params = unref(params);

  return axiosClient<ModelModules>({
    url: `/models/${slug}/modules`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

const getModelModulesQueryKey = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelModulesParams>,
) => {
  return ["models", slug, "modules", ...(params ? [params] : [])] as const;
};

export const useModelModulesQueryOptions = <
  TData = Awaited<ReturnType<typeof modelModules>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelModulesParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelModules>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelModulesQueryKey(slug, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelModules>>> = ({
    signal,
  }) => modelModules(slug, params, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof modelModules>>,
    TError,
    TData
  >;
};

export type ModelModulesQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelModules>>
>;
export type ModelModulesQueryError = ErrorType<StandardError>;

/**
 * @summary Model Modules
 */

export function useModelModules<
  TData = Awaited<ReturnType<typeof modelModules>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelModulesParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelModules>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = useModelModulesQueryOptions(slug, params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Module Packages
 */
export const modelModulePackages = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelModulePackagesParams>,
  signal?: AbortSignal,
) => {
  slug = unref(slug);
  params = unref(params);

  return axiosClient<ModelModulePackages>({
    url: `/models/${slug}/module-packages`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

const getModelModulePackagesQueryKey = (
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelModulePackagesParams>,
) => {
  return [
    "models",
    slug,
    "module-packages",
    ...(params ? [params] : []),
  ] as const;
};

export const useModelModulePackagesQueryOptions = <
  TData = Awaited<ReturnType<typeof modelModulePackages>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelModulePackagesParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelModulePackages>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelModulePackagesQueryKey(slug, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof modelModulePackages>>
  > = ({ signal }) => modelModulePackages(slug, params, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof modelModulePackages>>,
    TError,
    TData
  >;
};

export type ModelModulePackagesQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelModulePackages>>
>;
export type ModelModulePackagesQueryError = ErrorType<StandardError>;

/**
 * @summary Model Module Packages
 */

export function useModelModulePackages<
  TData = Awaited<ReturnType<typeof modelModulePackages>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  params?: MaybeRef<ModelModulePackagesParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelModulePackages>>,
        TError,
        TData
      >
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = useModelModulePackagesQueryOptions(
    slug,
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Upgrades
 */
export const modelUpgrades = (slug: MaybeRef<string>, signal?: AbortSignal) => {
  slug = unref(slug);

  return axiosClient<ModelUpgrade[]>({
    url: `/models/${slug}/upgrades`,
    method: "GET",
    signal,
  });
};

const getModelUpgradesQueryKey = (slug: MaybeRef<string>) => {
  return ["models", slug, "upgrades"] as const;
};

export const useModelUpgradesQueryOptions = <
  TData = Awaited<ReturnType<typeof modelUpgrades>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelUpgrades>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelUpgradesQueryKey(slug);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelUpgrades>>> = ({
    signal,
  }) => modelUpgrades(slug, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof modelUpgrades>>,
    TError,
    TData
  >;
};

export type ModelUpgradesQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelUpgrades>>
>;
export type ModelUpgradesQueryError = ErrorType<StandardError>;

/**
 * @summary Model Upgrades
 */

export function useModelUpgrades<
  TData = Awaited<ReturnType<typeof modelUpgrades>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelUpgrades>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = useModelUpgradesQueryOptions(slug, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Model Paints
 */
export const modelPaints = (slug: MaybeRef<string>, signal?: AbortSignal) => {
  slug = unref(slug);

  return axiosClient<ModelPaint[]>({
    url: `/models/${slug}/paints`,
    method: "GET",
    signal,
  });
};

const getModelPaintsQueryKey = (slug: MaybeRef<string>) => {
  return ["models", slug, "paints"] as const;
};

export const useModelPaintsQueryOptions = <
  TData = Awaited<ReturnType<typeof modelPaints>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelPaints>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelPaintsQueryKey(slug);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelPaints>>> = ({
    signal,
  }) => modelPaints(slug, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof modelPaints>>,
    TError,
    TData
  >;
};

export type ModelPaintsQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelPaints>>
>;
export type ModelPaintsQueryError = ErrorType<StandardError>;

/**
 * @summary Model Paints
 */

export function useModelPaints<
  TData = Awaited<ReturnType<typeof modelPaints>>,
  TError = ErrorType<StandardError>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelPaints>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = useModelPaintsQueryOptions(slug, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @deprecated
 * @summary Model Storeimage
 */
export const modelStoreImage = (
  slug: MaybeRef<string>,
  signal?: AbortSignal,
) => {
  slug = unref(slug);

  return axiosClient<unknown>({
    url: `/models/${slug}/store-image`,
    method: "GET",
    signal,
  });
};

const getModelStoreImageQueryKey = (slug: MaybeRef<string>) => {
  return ["models", slug, "store-image"] as const;
};

export const useModelStoreImageQueryOptions = <
  TData = Awaited<ReturnType<typeof modelStoreImage>>,
  TError = ErrorType<void>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelStoreImage>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelStoreImageQueryKey(slug);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelStoreImage>>> = ({
    signal,
  }) => modelStoreImage(slug, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof modelStoreImage>>,
    TError,
    TData
  >;
};

export type ModelStoreImageQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelStoreImage>>
>;
export type ModelStoreImageQueryError = ErrorType<void>;

/**
 * @deprecated
 * @summary Model Storeimage
 */

export function useModelStoreImage<
  TData = Awaited<ReturnType<typeof modelStoreImage>>,
  TError = ErrorType<void>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelStoreImage>>,
        TError,
        TData
      >
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = useModelStoreImageQueryOptions(slug, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @deprecated
 * @summary Model Fleetchart Image
 */
export const modelFleetchartImage = (
  slug: MaybeRef<string>,
  signal?: AbortSignal,
) => {
  slug = unref(slug);

  return axiosClient<unknown>({
    url: `/models/${slug}/fleetchart-image`,
    method: "GET",
    signal,
  });
};

const getModelFleetchartImageQueryKey = (slug: MaybeRef<string>) => {
  return ["models", slug, "fleetchart-image"] as const;
};

export const useModelFleetchartImageQueryOptions = <
  TData = Awaited<ReturnType<typeof modelFleetchartImage>>,
  TError = ErrorType<void | StandardError>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelFleetchartImage>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelFleetchartImageQueryKey(slug);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof modelFleetchartImage>>
  > = ({ signal }) => modelFleetchartImage(slug, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof modelFleetchartImage>>,
    TError,
    TData
  >;
};

export type ModelFleetchartImageQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelFleetchartImage>>
>;
export type ModelFleetchartImageQueryError = ErrorType<void | StandardError>;

/**
 * @deprecated
 * @summary Model Fleetchart Image
 */

export function useModelFleetchartImage<
  TData = Awaited<ReturnType<typeof modelFleetchartImage>>,
  TError = ErrorType<void | StandardError>,
>(
  slug: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelFleetchartImage>>,
        TError,
        TData
      >
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = useModelFleetchartImageQueryOptions(slug, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Available Model-Slugs
 */
export const modelsSlugs = (signal?: AbortSignal) => {
  return axiosClient<void>({ url: `/models/slugs`, method: "GET", signal });
};

const getModelsSlugsQueryKey = () => {
  return ["models", "slugs"] as const;
};

export const useModelsSlugsQueryOptions = <
  TData = Awaited<ReturnType<typeof modelsSlugs>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof modelsSlugs>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelsSlugsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsSlugs>>> = ({
    signal,
  }) => modelsSlugs(signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof modelsSlugs>>,
    TError,
    TData
  >;
};

export type ModelsSlugsQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelsSlugs>>
>;
export type ModelsSlugsQueryError = ErrorType<unknown>;

/**
 * @summary Available Model-Slugs
 */

export function useModelsSlugs<
  TData = Awaited<ReturnType<typeof modelsSlugs>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof modelsSlugs>>, TError, TData>
  >;
}): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = useModelsSlugsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Unscheduled Models
 */
export const modelsUnschduled = (signal?: AbortSignal) => {
  return axiosClient<void>({
    url: `/models/unscheduled`,
    method: "GET",
    signal,
  });
};

const getModelsUnschduledQueryKey = () => {
  return ["models", "unscheduled"] as const;
};

export const useModelsUnschduledQueryOptions = <
  TData = Awaited<ReturnType<typeof modelsUnschduled>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof modelsUnschduled>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelsUnschduledQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof modelsUnschduled>>
  > = ({ signal }) => modelsUnschduled(signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof modelsUnschduled>>,
    TError,
    TData
  >;
};

export type ModelsUnschduledQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelsUnschduled>>
>;
export type ModelsUnschduledQueryError = ErrorType<unknown>;

/**
 * @summary Unscheduled Models
 */

export function useModelsUnschduled<
  TData = Awaited<ReturnType<typeof modelsUnschduled>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof modelsUnschduled>>, TError, TData>
  >;
}): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = useModelsUnschduledQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Updated Models
 */
export const modelsUpdated = (
  params?: MaybeRef<ModelsUpdatedParams>,
  signal?: AbortSignal,
) => {
  params = unref(params);

  return axiosClient<void>({
    url: `/models/updated`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

const getModelsUpdatedQueryKey = (params?: MaybeRef<ModelsUpdatedParams>) => {
  return ["models", "updated", ...(params ? [params] : [])] as const;
};

export const useModelsUpdatedQueryOptions = <
  TData = Awaited<ReturnType<typeof modelsUpdated>>,
  TError = ErrorType<void>,
>(
  params?: MaybeRef<ModelsUpdatedParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelsUpdated>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelsUpdatedQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsUpdated>>> = ({
    signal,
  }) => modelsUpdated(params, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof modelsUpdated>>,
    TError,
    TData
  >;
};

export type ModelsUpdatedQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelsUpdated>>
>;
export type ModelsUpdatedQueryError = ErrorType<void>;

/**
 * @summary Updated Models
 */

export function useModelsUpdated<
  TData = Awaited<ReturnType<typeof modelsUpdated>>,
  TError = ErrorType<void>,
>(
  params?: MaybeRef<ModelsUpdatedParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof modelsUpdated>>, TError, TData>
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = useModelsUpdatedQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}

/**
 * @summary Models with Docks
 */
export const modelsWithDocks = (
  params?: MaybeRef<ModelsWithDocksParams>,
  signal?: AbortSignal,
) => {
  params = unref(params);

  return axiosClient<Models>({
    url: `/models/with-docks`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

const getModelsWithDocksQueryKey = (
  params?: MaybeRef<ModelsWithDocksParams>,
) => {
  return ["models", "with-docks", ...(params ? [params] : [])] as const;
};

export const useModelsWithDocksQueryOptions = <
  TData = Awaited<ReturnType<typeof modelsWithDocks>>,
  TError = ErrorType<unknown>,
>(
  params?: MaybeRef<ModelsWithDocksParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelsWithDocks>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getModelsWithDocksQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsWithDocks>>> = ({
    signal,
  }) => modelsWithDocks(params, signal);

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof modelsWithDocks>>,
    TError,
    TData
  >;
};

export type ModelsWithDocksQueryResult = NonNullable<
  Awaited<ReturnType<typeof modelsWithDocks>>
>;
export type ModelsWithDocksQueryError = ErrorType<unknown>;

/**
 * @summary Models with Docks
 */

export function useModelsWithDocks<
  TData = Awaited<ReturnType<typeof modelsWithDocks>>,
  TError = ErrorType<unknown>,
>(
  params?: MaybeRef<ModelsWithDocksParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof modelsWithDocks>>,
        TError,
        TData
      >
    >;
  },
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = useModelsWithDocksQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData>;

  return query;
}
